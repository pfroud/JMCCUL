/*
 * The MIT License.
 *
 * Copyright (c) 2022 Peter Froud.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package xyz.froud.jmccul;

import com.sun.jna.Structure;
import java.nio.IntBuffer;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;

/**
 * <i>native declaration : C:\Users\Public\Documents\Measurement Computing\DAQ\C\cbw.h</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br> a tool written by <a
 * href="http://ochafik.com/">Olivier Chafik</a> that <a
 * href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br> For help,
 * please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a
 * href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 *
 * @see <a
 *         href="https://www.mccdaq.com/pdfs/manuals/Mcculw_WebHelp/hh_goto.htm?ULStart.htm#Function_Reference/Device-Discovery/DaqDeviceDescriptor-type.htm">DaqDeviceDescriptor</a>
 */
public class DaqDeviceDescriptor extends Structure {

    /**
     * Product name of the detected device.
     */
    public byte[] ProductName = new byte[64];

    /**
     * A number associated with the detected device.
     */
    public int ProductID;

    /**
     * The bus type associated with the detected DAQ device.
     *
     * @see MeasurementComputingUniversalLibrary.DaqDeviceInterface
     */
    public int InterfaceType;

    /**
     * A character array associated with the detected device. For Ethernet devices, this value represents a NetBIOS
     * name. This value may be the same as the ProductName on some devices, but may contain more specific information on
     * other devices.
     */
    public byte[] DevString = new byte[64];

    /**
     * A string identifier that indicates the serial number of a detected USB device, or the MAC address of a detected
     * Bluetooth or Ethernet device.
     */
    public byte[] UniqueID = new byte[64];

    /**
     * Numeric representation of the unique identifier of the detected device.
     */
    public long NUID;

    /**
     * Reserved for the future use.
     */
    public byte[] Reserved = new byte[512];

    public DaqDeviceDescriptor() {
        super();
    }

    public DaqDeviceDescriptor(byte[] ProductName, int ProductID, int InterfaceType, byte[] DevString, byte[] UniqueID, long NUID, byte[] Reserved) {
        super();
        if ((ProductName.length != this.ProductName.length)) {
            throw new IllegalArgumentException("Wrong array size !");
        }
        this.ProductName = ProductName;
        this.ProductID = ProductID;
        this.InterfaceType = InterfaceType;
        if ((DevString.length != this.DevString.length)) {
            throw new IllegalArgumentException("Wrong array size !");
        }
        this.DevString = DevString;
        if ((UniqueID.length != this.UniqueID.length)) {
            throw new IllegalArgumentException("Wrong array size !");
        }
        this.UniqueID = UniqueID;
        this.NUID = NUID;
        if ((Reserved.length != this.Reserved.length)) {
            throw new IllegalArgumentException("Wrong array size !");
        }
        this.Reserved = Reserved;
    }

    @Override
    protected List<String> getFieldOrder() {
        return Arrays.asList("ProductName", "ProductID", "InterfaceType", "DevString", "UniqueID", "NUID", "Reserved");
    }

    @Override
    public String toString() {
        final DaqDeviceInterfaceType theInterface = getInterfaceType();
        return "product name \"" + getProductName() + "\" (productID " + ProductID
                + "); interface type " + theInterface.DISPLAY_NAME + "; "
                + theInterface.LABEL_FOR_UNIQUE_ID + " \"" + getUniqueID() + "\" (" + NUID + ")";
    }

    public DaqDeviceInterfaceType getInterfaceType() {
        return DaqDeviceInterfaceType.parseInt(InterfaceType);
    }

    public String getUniqueID() {
        return new String(UniqueID).trim();
    }

    public String getProductName() {
        return new String(ProductName).trim();
    }

    /**
     * When used as a function parameter or return value, the {@code com.sun.jna.Structure} class corresponds to
     * {@code struct*}. When used as a field within another {@code Structure}, it corresponds to {@code struct}. The
     * tagging interfaces {@code Structure.ByReference} and {@code Structure.ByValue} may be used to alter the default
     * behavior.
     *
     * @see <a href="http://java-native-access.github.io/jna/5.12.1/javadoc/com/sun/jna/Structure.html">
     * http://java-native-access.github.io/jna/5.12.1/javadoc/com/sun/jna/Structure.html</a>
     * @see <a
     *         href="http://java-native-access.github.io/jna/5.12.1/javadoc/com/sun/jna/Structure.ByValue.html">http://java-native-access.github.io/jna/5.12.1/javadoc/com/sun/jna/Structure.ByValue.html</a>
     */
    public static class ByValue extends DaqDeviceDescriptor implements Structure.ByValue {
        // empty
    }

    /**
     * Converts a DaqDeviceDescriptor into a DaqDeviceDescriptor.ByValue.
     *
     * @see <a href="https://stackoverflow.com/a/26309505">https://stackoverflow.com/a/26309505</a>
     * @see <a href="https://github.com/java-native-access/jna/issues/691#issuecomment-242814602">
     * https://github.com/java-native-access/jna/issues/691#issuecomment-242814602</a>
     * @see <a
     *         href="http://java-native-access.github.io/jna/5.12.1/javadoc/com/sun/jna/Structure.html#newInstance-java.lang.Class-com.sun.jna.Pointer-">
     * Javadoc for Structure.newInstance() method</a>
     * @see <a href="http://java-native-access.github.io/jna/5.12.1/javadoc/com/sun/jna/Structure.html#getPointer--">
     * Javadoc for getPointer() method</a>
     */
    public DaqDeviceDescriptor.ByValue byValue() {
        final DaqDeviceDescriptor.ByValue rv = Structure.newInstance(
                DaqDeviceDescriptor.ByValue.class,
                getPointer()
        );
        // if you don't call read() you'll get error 306
        rv.read();
        return rv;
    }

    /**
     * Returns the board number of the DAQ device created from this descriptor, or –1 if a DAQ device hasn't been
     * created.
     *
     * @return The board number or –1.
     *
     * @see <a
     *         href="https://www.mccdaq.com/pdfs/manuals/Mcculw_WebHelp/hh_goto.htm?ULStart.htm#Function_Reference/Device-Discovery/cbGetBoardNumber.htm">cbGetBoardNumber()</a>
     * @see <a
     *         href="https://www.mccdaq.com/pdfs/manuals/Mcculw_WebHelp/hh_goto.htm?ULStart.htm#Function_Reference/Device-Discovery-NET/GetBoardNumber.htm">GetBoardNumber()</a>
     */
    public int getBoardNumber() {
        return MeasurementComputingUniversalLibrary.INSTANCE.cbGetBoardNumber(byValue());
    }

    //<editor-fold desc="discovery">
    /**
     * Detects USB, Bluetooth and/or Ethernet DAQ devices, and returns device descriptors of the detected devices.
     * <p>
     * This function detects Ethernet DAQ devices on the same subnet as the host PC. To detect Ethernet DAQ devices on a
     * different subnet than the host PC, use cbGetNetDeviceDescriptor().
     * <p>
     * You may optionally filter DAQ devices by interface type. If no interface types are specified for the filter, then
     * the filter is set to {@link xyz.froud.jmccul.DaqDeviceInterfaceType#ANY}. So, these three calls do the same
     * thing:
     * <ul>
     * <li>{@code findDescriptors()}</li>
     * <li>{@code findDescriptors(DaqDeviceInterfaceType.ANY)}</li>
     * <li>{@code findDescriptors(DaqDeviceInterfaceType.USB, DaqDeviceInterfaceType.BLUETOOTH, DaqDeviceInterfaceType.ETHERNET)}</li>
     * </ul>
     *
     * @param interfaceTypeFilter which interface type(s) should be searched for DAQ devices. If no interface types are
     * specified, then all interface types are searched.
     *
     * @see <a
     *         href="https://www.mccdaq.com/pdfs/manuals/Mcculw_WebHelp/hh_goto.htm?ULStart.htm#Function_Reference/Device-Discovery/cbGetDaqDeviceInventory.htm">cbGetDaqDeviceInventory()</a>
     * @see <a
     *         href="https://www.mccdaq.com/pdfs/manuals/Mcculw_WebHelp/hh_goto.htm?ULStart.htm#Function_Reference/Device-Discovery-NET/GetDaqDeviceInventory.htm">GetDaqDeviceInventory()</a>
     */
    public static DaqDeviceDescriptor[] find(DaqDeviceInterfaceType... interfaceTypeFilter) throws JMCCULException {

        // Can be any arbitrary number, just needed so C can allocate stuff
        final int MAX_DEVICE_COUNT = 16;

        /*
        Allocate an array of empty DaqDeviceDescriptors. The cbGetDaqDeviceInventory() call will populate this array.
        See Stack Overflow answer to 'How to fill an array of structures in JNA?' https://stackoverflow.com/a/25186232
        */
        final DaqDeviceDescriptor[] buffer = (DaqDeviceDescriptor[]) new DaqDeviceDescriptor().toArray(MAX_DEVICE_COUNT);

        /*
        The deviceCount variable is used both an input and output to cbGetDaqDeviceInventory().
        As an input, it is the length of the DaqDeviceDescriptor array.
        As an output, it is how many DAQ devices were actually found.
        */
        final IntBuffer deviceCount = IntBuffer.wrap(new int[]{MAX_DEVICE_COUNT});

        final int interfaceBitMask;
        if (interfaceTypeFilter.length == 0) {
            interfaceBitMask = DaqDeviceInterfaceType.ANY.VALUE;
        } else {
            interfaceBitMask = DaqDeviceInterfaceType.bitwiseOr(interfaceTypeFilter);
        }

        /*
        https://www.mccdaq.com/pdfs/manuals/Mcculw_WebHelp/hh_goto.htm?ULStart.htm#Function_Reference/Device-Discovery/cbGetDaqDeviceInventory.htm

        In the original C method, the DaqDeviceDescriptor parameter has type DaqDeviceDescriptor* (with star).
        JNAerator changed it to DaqDeviceDescriptor (without star).
        According to http://java-native-access.github.io/jna/5.12.1/javadoc/com/sun/jna/Structure.html:
        When used as a function parameter or return value, the com.sun.jna.Structure class corresponds to struct*.
        so that is okay.

        According to https://stackoverflow.com/a/25186232, we need to pass the 0th element of the DaqDeviceDescriptor array.
        */
        final int errorCode = MeasurementComputingUniversalLibrary.INSTANCE.cbGetDaqDeviceInventory(interfaceBitMask, buffer[0], deviceCount);
        JMCCULUtils.checkError(errorCode);

        // After calling cbGetDaqDeviceInventory(), deviceCount now contains how many devices were actually found.
        final int devicesFoundCount = deviceCount.get(0);

        // The buffer still has MAX_DEVICE_COUNT elements in it. Return a subarray with only found devices.
        return Arrays.copyOf(buffer, devicesFoundCount);
    }

    public static Optional<DaqDeviceDescriptor> findFirst() throws JMCCULException {
        return Arrays.stream(find()).findAny();
    }

    public static Optional<DaqDeviceDescriptor> findFirstMatching(Predicate<DaqDeviceDescriptor> predicate) throws JMCCULException {
        return Arrays.stream(find()).filter(predicate).findFirst();
    }
    //</editor-fold>
}
